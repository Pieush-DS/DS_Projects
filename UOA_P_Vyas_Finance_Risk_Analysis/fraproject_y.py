# -*- coding: utf-8 -*-
"""FRAProject.ipynb

Automatically generated by Colaboratory.

"""


import os
import datetime
import pandas as pd
import numpy as np
import streamlit as st
import matplotlib.pyplot as plt
from scipy.stats import pearsonr
from scipy.stats import norm

st.set_page_config(
    page_title = 'Stock Portfolio Dashboard',
    layout = 'wide'
)








# --------------------Task 1: Data Import----------------------#

directory_path = "C:/Users/lenovo/Desktop/Assignment/Dataset"
# Loading the annexure file

annexure = pd.read_csv( directory_path + "/Annexure-I.csv" )

# Merging Healthcare & Pharmaceuticals into one

annexure.loc[annexure["Industry"] == "Healthcare","Industry"] = "Pharma"
annexure.loc[annexure["Industry"] == "Pharmaceuticals","Industry"] = "Pharma"

# Correcting a typo in annexure file

annexure.loc[annexure["Ticker"] == "UNH ","Ticker"] = "UNH"

industries = ["Aviation","Finance","Pharma","Technology"]


# Mapping industries to companies

i2c = {}

for i,ind in enumerate(industries):
  i2c[ind] = annexure[annexure["Industry"] == industries[i]]["Ticker"].to_list()

i2c["Pharma"][3] = "UNH"


# Mapping companies to industries

def get_industry(comp):
  return (annexure[annexure["Ticker"] == comp])["Industry"]

stocklist = [
    "AAL","ALGT","ALK","DAL","HA","LUV",
    "BCS","CS","DB","GS","MS","WFC",
    "BHC","JNJ","MRK","PFE","RHHBY","UNH",
    "AAPL","AMZN","FB","GOOG","IBM","MSFT"
  ]

# Importing all 25 csv files

for industry in industries:
  for stock in i2c[industry]:
    globals()[stock.lower()+"_data"] = pd.read_csv( directory_path + "/" + industry + "/" + stock + ".csv")


snp500 = pd.read_csv( directory_path + "/S&P500.csv" )

datalist =  [ 
     aal_data , algt_data , alk_data , dal_data , ha_data , luv_data ,
     bcs_data , cs_data , db_data , gs_data , ms_data , wfc_data ,
     bhc_data , jnj_data , mrk_data , pfe_data , rhhby_data , unh_data ,
     aapl_data , amzn_data , fb_data , goog_data , ibm_data , msft_data 
  ]

# Adding StockName to each data frame

for i in range(len(datalist)):
  datalist[i]["StockName"] = stocklist[i]
  datalist[i]["Industry"] = get_industry(stocklist[i]).iloc[0]
  # print(stocklist[i])
  # print(get_industry(stocklist[i]).iloc[0])

# Merging all data

df = pd.concat(datalist)

# Assess data using StockName

def get_stock_data(name):
  data = df[df['StockName'] == name]
  return data

# Drop null data

df = df.dropna()












# ---------------- STREAMLIT DASHBOARD ----------------#


# ---- SIDEBAR ----
st.sidebar.header("Please Filter Here:")

industry = st.sidebar.selectbox(
    'Please Select Industry',
    options=df["Industry"].unique())

stockName = st.sidebar.selectbox(
    'Please Select Stock',
    options=df[df["Industry"] == industry]["StockName"].unique())

st.sidebar.write('Selected Industry:', industry)

st.sidebar.write('Selected Stock:', stockName)






df_selection = df.query(
    "StockName == @stockName"
)



	# ---- MAINPAGE ----
st.title(":bar_chart: Sales Dashboard of " + stockName)
st.markdown("##")

# st.subheader(f"Dataframe")
# st.dataframe(df_selection)


def to_date(d):
  return datetime.datetime.strptime(d, "%d-%m-%Y").date()



#Task2 - Daily Returns


def stock_visualization(stock):
  data = get_stock_data(stock)
  data['index'] = np.arange(0,data.shape[0])
  
  data.rename(columns = {'Close':'Closing price'}, inplace = True)

  st.subheader("Closing Price of " + stock)
  dr = pd.DataFrame(data,columns=['Closing price','index'])
  st.line_chart(data=dr, y = "Closing price")
  st.markdown("##")

stock_visualization(stockName)



# Closing price normalised

def normalized_price(stock):
  data = get_stock_data(stock)["Close"]
  norm = [i/np.max(data) for i in data]

  st.subheader("Normalised closing Price of " + stock)
  dr = pd.DataFrame(norm,columns=['Closing price'])
  st.line_chart(dr,y = "Closing price")
  st.markdown("##") 

normalized_price(stockName)




# To calculate the daily returns of a stock
def daily_returns(stock):
    data = get_stock_data(stock)
    size = get_stock_data(stock).shape[0]

    daily_returns = []
    for i in range(1,size):
      daily_returns.append(100*(data.iloc[i]["Close"] - data.iloc[i-1]["Close"])/data.iloc[i-1]["Close"])
  
    st.subheader("Daily Returns(%)" )
    dr = pd.DataFrame(daily_returns,columns=['Daily Returns'])
    st.line_chart(dr.iloc[-500:],y="Daily Returns")
    st.markdown("##")

daily_returns(stockName)






# Dispertion from mean

# To compare the Closing price of each day and moving average of a stock
st.subheader("Dispersion from mean")

def dispertion_from_mean(stock):
  data = get_stock_data(stock)
  size = data.shape[0]

  moving_mean = []
  cur_sum = 0

  for i in range(0,size):
    cur_sum += data.iloc[i]["Close"]
    mean = cur_sum/(i+1)
    moving_mean.append(mean)

  data["Moving average"] = moving_mean
  data.rename(columns = {'Close':'Closing Price'}, inplace = True)

  
  dr = pd.DataFrame(data,columns=['Closing Price','Moving average'])
  st.line_chart(dr,y="")
  st.markdown("##")


dispertion_from_mean(stockName)





#Max and Min during specific period

def to_date(d):
  return datetime.datetime.strptime(d, "%d-%m-%Y").date()

def get_extreme_date(stock):
  data = get_stock_data(stock)["Date"]

  stdate = data.iloc[0].split("-")
  enddate = data.iloc[-1].split("-")
  return stdate,enddate



st.subheader("Max and Min during specific period")
# function to calculate the max price and min price during a specified period

def max_min(st,end,stock):
  data = get_stock_data(stock)
  size = data.shape[0]

  strt_date = to_date(st)
  end_date = to_date(end)

  mx = mn = 0  
  for i in range(0,size):
    if to_date(data["Date"].iloc[i]) >= strt_date:
      mn = i
      break

  for i in range(mn,size):
    if to_date(data["Date"].iloc[i]) >= end_date:
      mx = i
      break

  return data["Close"].iloc[mn:mx].max(axis = 0), data["Close"].iloc[mn:mx].min(axis = 0)




left_column, right_column = st.columns(2)
stdate,enddate = get_extreme_date(stockName)


with left_column:
  start_date = st.date_input(
      "Pick the starting date:",
      datetime.date(int(stdate[2]), int(stdate[1]), int(stdate[0])),
      min_value=datetime.date(int(stdate[2]), int(stdate[1]), int(stdate[0]))
      )
  start_date = start_date.strftime("%d-%m-%Y")

with right_column:
  end_date = st.date_input(
      "Pick the ending date:",
      datetime.date(int(enddate[2]), int(enddate[1]), int(enddate[0])),
      max_value=datetime.date(int(enddate[2]), int(enddate[1]), int(enddate[0])))
  end_date = end_date.strftime("%d-%m-%Y")

res = max_min(start_date,end_date,stockName)

st.write('Max Closing price : ' + "  " + str(res[0])[:5])
st.write('Min Closing price : ' + "  " + str(res[1])[:5])






# ------------- Risk/Volatility-------------



# This calculates Risk/volatility of a stock by calculating variance of daily returns.

def volatility(stock):
  data = get_stock_data(stock)
  size = get_stock_data(stock).shape[0]

  daily_returns = []
  for i in range(0,size):
    daily_returns.append(100*(data.iloc[i]["Close"] - data.iloc[i-1]["Close"])/data.iloc[i-1]["Close"])

  return np.var(daily_returns)

st.subheader("Risk/Volatility : " + str(volatility(stockName))[:6])




# ------------------ Stock comparison ------------------


# This compares normalized closing prices of 2 stocks

st.subheader("Comparison with other stocks")

def compare(stock1,stock2):
  dr1 = get_stock_data(stock1)["Close"]
  dr2 = get_stock_data(stock2)["Close"]

  dr1n = [i/np.max(dr1) for i in dr1]
  dr2n = [i/np.max(dr2) for i in dr2]

  length = min(len(dr1),len(dr2))
  

  data = pd.DataFrame(np.column_stack([dr1n[:length],dr2n[:length]]), 
                               columns=[stock1, stock2])

  st.line_chart(data)


industrycmp = st.selectbox(
    'Please Select Industry',
    options=df["Industry"].unique(),
    key="2")

stockcmp = st.selectbox(
    'Please Select Stock',
    options=df[df["Industry"] == industrycmp]["StockName"].unique(),
    key="3")


compare(stockName,stockcmp)






# ------------------ Correlation analysis ------------------

# This calculates Correlation of any 2 given stocks

st.subheader("Correlation with other stocks")
def get_correlation(stock1,stock2):
  data1 = get_stock_data(stock1)
  data2 = get_stock_data(stock2)
  
  dr1 = ((data1['Close'] - data1['Close'].shift(1))/data1['Close'].shift(1))[1:]
  dr2 = ((data2['Close'] - data2['Close'].shift(1))/data2['Close'].shift(1))[1:]

  length = min(len(dr1),len(dr2))

  return pearsonr(dr1[:length],dr2[:length])[0]



industrycoerr = industrycmp
stockcoerr = stockcmp

st.write( "Correlation with " + stockcoerr + " : " , get_correlation(stockName,stockcoerr))








# ------------------ Visualizing Daily returns data ------------------

# This buckets the daily returns of a stock and plots a PDF

st.subheader("Visualizing Daily returns data")

def prob_dist_daily_returns(stock):

  data = get_stock_data(stock)

  returns = ((data['Close'] - data['Close'].shift(1))/data['Close'].shift(1))[1:]

  left_column, right_column = st.columns(2)

  with left_column:
    fig, ax = plt.subplots(figsize=(9, 5))
    ax.hist(returns,bins="rice", label="Daily returns")
    ax.legend()
    st.pyplot(fig)

  with right_column:
    fig, ax = plt.subplots(figsize=(9, 5))
    ax.boxplot(returns,labels=["Daily close price"])
    st.pyplot(fig)

prob_dist_daily_returns(stockName)








# ------------------ Comparison from normal distribution ------------------

# This draws a plot that compares the distribution of stock price from gaussian normal distribution 

st.subheader("Daily Returns Vs Normal distribution")

def comparasion_from_normal_dist(stock):

  data = get_stock_data(stock)

  returns = ((data['Close'] - data['Close'].shift(1))/data['Close'].shift(1))[1:]

  t = np.linspace(0.01,0.99,1000)
  q1 = np.quantile(returns,t)
  q2 = norm.ppf(t,loc=np.mean(returns),scale=np.std(returns))

  left_column, right_column = st.columns(2)

  with left_column:
    fig = plt.figure(figsize=(8,5)) 
    plt.plot(q1,q2,label="Daily returns")
    plt.plot([np.min(q1),np.max(q1)],[np.min(q2),np.max(q2)],label="Normal distribution")
    plt.xlim((np.min(q1),np.max(q1)))
    plt.ylim((np.min(q2),np.max(q2)))
    plt.xlabel("Daily returns")
    plt.ylabel("Normal distribution")
    plt.legend()
    plt.show()
    st.pyplot(fig)

comparasion_from_normal_dist(stockName)